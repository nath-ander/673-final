<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <title>Households with Computers</title>
    <!-- Bootstrap CSS -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65"
      crossorigin="anonymous"
    />
    <!-- Leaflet CSS -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css"
      integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI="
      crossorigin=""
    />
    <!-- Fonts -->
    <link
      href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,400;0,800;1,800&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        margin: 0;
        padding: 0;
        background-color: #333;
        font-family: "Open sans", sans-serif;
        font-weight: 300;
        font-size: 100%;
      }

      h1 {
        font-weight: 900;
        font-size: calc(1.5rem + ((100vw â€“ 400) / 400));
        color: "#2e2e2e";
        letter-spacing: 0.02em;
        margin: 5px 0;
      }

      h2 {
        font-weight: 500;
        font-size: 2.3em;
        letter-spacing: 0.04em;
        text-decoration: underline;
        margin: 5px 0;
      }

      h3 {
        font-size: 1.5em;
        margin-bottom: 5px;
      }

      p {
        font-size: 1.3em;
        margin-bottom: 5px;
      }

      a {
        color: #004a8b;
        font-weight: 400;
        text-decoration: none;
      }

      a:hover {
        text-decoration: underline;
      }

      ul {
        padding: 0px 20px 4px 20px;
        font-size: 1.1em;
        line-height: 1.2em;
        color: #63666a;
      }

      li {
        margin: 10px 0;
      }

      #map {
        height: calc(60vh);
        background: #3f3f3f;
      }

      header {
        height: 80px;
      }

      footer {
        height: 50px;
        background-color: #262527;
        font-size: 0.7rem;
      }

      aside {
        height: calc(40vh - 130px);
      }

      #legend {
        padding: 6px 8px;
        font-size: 1rem;
        border-radius: 5px;
        max-width: 200px;
        color: rgba(244, 244, 244, 0.8);
        border-radius: 5px;
      }

      #legend span {
        width: 20px;
        height: 20px;
        float: left;
        margin: 0 10px 4px 0;
      }

      #legend label {
        font-size: 0.9rem;
      }

      #legend label:after {
        content: "";
        display: block;
        clear: both;
      }

      .container-fluid {
        background-color: #333;
      }

      #dropdown-ui {
        appearance: none;
        outline: none;
        border: none;
        margin: 1rem;
        position: relative;
        overflow: hidden;
      }

      #mobile {
        display: none;
        height: 100%;
        width: 100%;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        z-index: 5000;
        opacity: 0.9;
      }

      .message {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #fff;
        font-size: 1.5rem;
        text-align: center;
      }

      /* Landscape devices all scenarios */
      @media (orientation: landscape) {
        aside {
          display: block;
          height: calc(100vh - 130px);
        }

        #map {
          height: calc(100vh - 130px);
        }
      }

      /* Small devices (landscape phones, 576px and up) */
      @media (min-width: 576px) {
        aside {
          display: block;
          height: calc(100vh - 130px);
        }

        #map {
          height: calc(100vh - 130px);
        }
      }

      /* Medium devices (tablets, 768px and up) */
      @media (min-width: 768px) {
        aside {
          display: block;
          height: calc(100vh - 160px);
        }

        #map {
          height: calc(100vh - 160px);
        }

        header {
          height: 100px;
        }

        footer {
          height: 60px;
          font-size: 1rem;
        }

        h1 {
          font-size: 2.8em;
        }
      }

      /* Large devices (desktops, 992px and up) */
      @media (min-width: 992px) {
      }

      /* Extra large devices (large desktops, 1200px and up) */
      @media (min-width: 1200px) {
      }
    </style>
  </head>

  <body>
    <div id="mobile">
      <div class="message">
        This map is best viewed on a desktop or laptop computer. Click to
        continue.
      </div>
    </div>
    <div class="container-fluid">
      <header class="row bg-dark text-white py-3">
        <div class="col">
          <h1>Households with computers</h1>
        </div>
      </header>

      <section class="row">
        <div class="col-md-8 col-lg-9 col-xl-10 order-md-2 px-0">
          <div id="map"></div>
        </div>
        <aside
          id="about"
          class="col-md-4 col-lg-3 col-xl-2 order-md-1 text-white py-2 pl-3 bg-secondary overflow-auto"
        >
          <section>
            <p class="py-2">
              What percentage of households have computers? We define computers
              as desktop/laptop or a mobile device.
            </p>
            <p>This map is based on 2020 ACS 5-year US Census data.</p>
            <button id="geolocate-ui">Enable geolocation</button>
            <div id="locateFeedback"></div>
          </section>
        </aside>
      </section>

      <footer class="row bg-dark text-white py-1 px-2 fixed-bottom">
        <div class="col">
          <ul class="list-unstyled">
            <li>
              Data source:
              <a
                href="https://www.census.gov/data/developers/guidance/api-user-guide.Overview.html"
                >US Census Data API</a
              >
            </li>
          </ul>
        </div>
      </footer>
    </div>

    <!-- legend is outside of container-fluid and will be dynamically added to map -->
    <div class="bg-secondary py-2 px-3 ml-3 mt-3 text-white" id="legend"></div>

    <!-- ui is outside of container-fluid and will be dynamically added to map -->
    <div class="form-group mr-3 mt-3" id="dropdown-ui">
      <select class="form-select bg-primary text-white"></select>
    </div>

    <!-- Add Bootstrap -->
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4"
      crossorigin="anonymous"
    ></script>
    <!-- then Leaflet JS -->
    <script
      src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"
      integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM="
      crossorigin=""
    ></script>
    <!-- then Simple Statistics -->
    <script src="https://unpkg.com/simple-statistics@7.8.2/dist/simple-statistics.min.js"></script>
    <script src="data.js"></script>
    <script>
      if (L.Browser.mobile) {
        const overlay = document.getElementById("mobile");
        overlay.style.display = "block";
        overlay.addEventListener("click", () => {
          overlay.style.display = "none";
          overlay.style.zIndex = "-1";
        });
        a.legend.options.position = "bottomleft";
        a.map.zoomOptions = null;
      }

      createMap();
      console.log(a);

      function createMap() {
        a.map.placed = L.map(a.map.div, a.map.options);
        if (a.map.zoomOptions) {
          L.control.zoom(a.map.zoomOptions).addTo(a.map.placed);
        }

        L.tileLayer(a.tiles.url, a.tiles.options).addTo(a.map.placed);
        getCensus();
        locateUI();
      }

      function getCensus() {
        a.query = a.variables.map((v) => v.var).join(",");
        a.url = `https://api.census.gov/data/${a.domain.data}?get=NAME,${a.query}&for=${a.domain.unit}:*&in=state:${a.domain.state}`;
        a.censusAPI = fetch(a.url).then(function (r) {
          return r.json();
        });
        a.geometry = fetch(a.geojsons.counties).then(function (r) {
          return r.json();
        });
        Promise.all([a.censusAPI, a.geometry])
          .then(function (response) {
            a.data.censusData = response[0];
            a.data.geometryData = response[1];
            for (let n of a.data.censusData) {
              const l = n.length;
              const countyFips = n[l - 2] + n[l - 1];
              for (const m of a.data.geometryData.features) {
                const geoid = m.properties.GEOID;
                if (geoid == countyFips) {
                  m.properties.census = {};
                  for (let i = 0; i < a.variables.length; i++) {
                    m.properties.census[a.variables[i].name] = n[i + 1];
                  }
                  break;
                }
              }
            }
            drawMap();
          })
          .catch(function (error) {
            console.log(error);
          });
      }

      function drawMap() {
        a.layers.placed = L.geoJson(a.data.geometryData, {
          style: function (feature) {
            return a.map.styles.default;
          },
          onEachFeature: function (feature, layer) {
            layer.on("mouseover", function () {
              layer.setStyle(a.map.styles.mouseover).bringToFront();
            });
            layer.on("mouseout", function () {
              layer.setStyle(a.map.styles.mouseout);
            });
          },
          filter: function (feature) {
            for (let i of a.domain.state) {
              if (i == "*") {
                return true;
              } else if (feature.properties.STATEFP == i) {
                return true;
              }
            }
          },
        }).addTo(a.map.placed);
        a.map.placed.fitBounds(a.layers.placed.getBounds(), a.map.fitOptions);
        updateMap();
        addUi();
        addLegend();
        // a.data = null
      }

      function updateMap() {
        getClassBreaks();
        const breaks = a.classes.breaks;
        a.layers.placed.eachLayer(function (layer) {
          const props = layer.feature.properties;
          if (props.census) {
            layer.setStyle({
              fillColor: a.legend.getColor(
                props.census[a.vars.aV] / props.census[a.vars.nV],
                breaks,
                a.classes.number
              ),
            });
            let tooltipInfo = a.map.tooltip(
              props["NAME"],
              props.census[a.vars.aV],
              props.census[a.vars.nV]
            );
            layer.bindTooltip(tooltipInfo, {
              // sticky: true,
            });
          } else {
            layer.setStyle({
              fillColor: "#ccc",
            });
            layer.bindTooltip("No data", {
              // sticky: true,
            });
          }

          if (props.COUNTYFP == a.domain.county) {
            layer.openTooltip();
          }
        });
        updateLegend();
      }

      function getClassBreaks() {
        const values = [];
        a.layers.placed.eachLayer(function (layer) {
          if (layer.feature.properties) {
            const props = layer.feature.properties;
            if (props.census) {
              values.push(props.census[a.vars.aV] / props.census[a.vars.nV]);
            }
          }
        });
        const cluster = ss.ckmeans(values, a.classes.number);
        const breaks = cluster.map(function (cluster) {
          return [cluster[0], cluster.pop()];
        });
        a.classes.breaks = breaks;
      }

      function addLegend() {
        const legendControl = L.control(a.legend.options);
        legendControl.onAdd = function () {
          const legend = L.DomUtil.get(a.legend.div);
          L.DomEvent.disableScrollPropagation(legend);
          L.DomEvent.disableClickPropagation(legend);
          return legend;
        };
        legendControl.addTo(a.map.placed);
      }

      function updateLegend() {
        const breaks = a.classes.breaks;
        for (let findLabel of a.variables) {
          if (findLabel.name == a.vars.aV) {
            legend.innerHTML = `<h5>${findLabel.label}</h5>`;
          }
        }
        for (let i = 0; i <= breaks.length - 1; i++) {
          let color = a.legend.getColor(breaks[i][0], breaks, a.classes.number);
          const classLabel = a.legend.makePercent(
            breaks[i][0],
            breaks[i][1],
            color
          );
          legend.innerHTML += classLabel;
        }
      }

      function addUi() {
        a.buttons.dropdown.placed = document.querySelector(
          a.buttons.dropdown.select
        );
        a.buttons.dropdown.placed.innerHTML = "";
        for (let i = 1; i < a.variables.length; i++) {
          let option = document.createElement("option");
          option.textContent = a.variables[i].label;
          option.value = a.variables[i].name;
          if (a.variables[i].name == a.vars.aV) {
            option.selected = true;
          }
          a.buttons.dropdown.placed.appendChild(option);
        }
        const selectControl = L.control(a.buttons.dropdown.options);
        selectControl.onAdd = function () {
          return L.DomUtil.get(a.buttons.dropdown.id);
        };
        selectControl.addTo(a.map.placed);
        a.buttons.dropdown.placed.addEventListener("change", function (e) {
          a.vars.aV = e.target.value;
          updateMap();
        });
      }

      function locateUI() {
        a.buttons.locate.placed = document.querySelector(a.buttons.locate.id);
        a.location.info = document.querySelector(a.location.feedBack);
        a.buttons.locate.placed.addEventListener("click", function () {
          geoLocate();
        });
      }

      function geoLocate() {
        a.buttons.locate.placed.innerHTML = "Locating...";

        let hiAcc = false;
        if (L.Browser.mobile) {
          hiAcc = true;
        }
        let bnds = L.latLngBounds();
        let n = 0;
        let timer;
        const nowPosition = function (position) {
          const lat = position.coords.latitude;
          const lng = position.coords.longitude;
          const latlng = L.latLng(lat, lng);
          bnds.extend(latlng);
          n++;
          console.log(n);
          if (n == 5) {
            clearInterval(timer);
            a.location.center = bnds.getCenter();
            a.buttons.locate.placed.innerHTML = "Location found";
            drawMapOnLocation();
          }
        };

        const error = function (err) {
          const feedback = a.location.info;
          err.message
            ? (feedback.innerHTML = err.message)
            : (feedback.innerHTML = `No geolocation available on this browser.`);
        };

        timer = setInterval(() => {
          navigator.geolocation.getCurrentPosition(nowPosition, error, {
            enableHighAccuracy: hiAcc,
            maximumAge: 0,
          });
        }, 1000);
      }

      function drawMapOnLocation() {
        L.geoJson(a.data.geometryData).eachLayer(function (layer) {
          const props = layer.feature.properties;
          if (layer.getBounds().contains(a.location.center)) {
            a.domain.county = props.COUNTYFP;
            a.domain.state = [];
            a.domain.state.push(props.STATEFP);
            getCensus();
            a.layers.placed.remove();
          }
        });
      }
    </script>
  </body>
</html>
